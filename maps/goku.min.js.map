{"version":3,"sources":["goku.js","transition.js"],"names":["exports","newId","gokuIndex","goku","element","Error","document","querySelector","elements","dataset","gokuId","id","Transition","onstart","animatingElements","indexOf","push","requestId","console","log","requestAnimationFrame","step","oncomplete","splice","length","cancelAnimationFrame","timestamp","forEach","window","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setTimeout","webkitCancelAnimationFrame","mozCancelAnimationFrame","clearTimeout","options","this","isStarted","_reset","bind","cssText","style","defaultStyle","queue","originalTimings","timings","playingIndex","elapsedTime","lastTimestamp","isPaused","isPauseHandled","promiseQueue","animate","delay","pause","DEFAULT_DURATION","DEFAULT_EASING","DEFAULT_SPEED_RATIO","prototype","_generatePromiseTask","promiseTask","promise","Promise","resolve","reject","_generateTransform","value","originalTransform","getComputedStyle","transform","_generateTransformByMatrix","addClass","args","Array","slice","call","arguments","properties","transitionPropertyArray","key","transitionProperty","join","duration","that","task","start","transitionDuration","transitionTimingFunction","easing","offsetWidth","time","play","reset","reverse","speed","ratio","jumpToEnd","remainingTime","styles","newTiming","i","stop","_goto","_next","index","finish","complete","before","_clear"],"mappings":"CACA,SAAAA,GACA,YAsCA,SAAAC,KACA,MAAA,QAAAC,IAGA,QAAAC,GAAAC,GACA,IAAAA,EACA,KAAA,IAAAC,OAAA,oBAOA,IAJA,gBAAAD,KACAA,EAAAE,SAAAC,cAAAH,KAGAA,EACA,KAAA,IAAAC,OAAA,yBAGA,IAAAG,EAAAJ,EAAAK,QAAAC,QACA,MAAAF,GAAAJ,EAAAK,QAAAC,OAQA,IAAAC,GAAAV,GA6BA,OA3BAG,GAAAK,QAAAC,OAAAC,EAEAH,EAAAG,GAAA,GAAAC,YAAAR,GACAO,GAAAA,EACAE,QAAA,SAAAF,GACAG,EAAAC,QAAAJ,GAAA,GACAG,EAAAE,KAAAL,GAEAM,IACAC,QAAAC,IAAA,iCACAF,EAAAG,EAAAC,KAGAC,WAAA,SAAAlB,GACA,GAAAO,GAAAP,EAAAK,QAAAC,MAEAI,GAAAC,QAAAJ,GAAA,IACAG,EAAAS,OAAAT,EAAAC,QAAAJ,GAAA,GAEAG,EAAAU,OAAA,IACAN,QAAAC,IAAA,oCACAM,EAAAR,GACAA,EAAA,SAKAT,EAAAG,GAQA,QAAAU,GAAAK,GACAT,EAAAG,EAAAC,GAEAP,EAAAa,QAAA,SAAAhB,GACAH,EAAAG,GAAAU,MACAb,EAAAG,GAAAU,KAAAK,KAxGA,GAAAT,GAEAT,KAEAM,KAEAZ,EAAA,EAEAkB,EAAAQ,OAAAR,uBACAQ,OAAAC,6BACAD,OAAAE,0BACA,SAAAC,GACA,MAAAH,QAAAI,WAAAD,EAAA,IAAA,KAGAN,EAAAG,OAAAH,sBACAG,OAAAK,4BACAL,OAAAM,yBACA,SAAAvB,GACAiB,OAAAO,aAAAxB,GA0FAX,GAAAG,KAAAA,GAEAyB,QCnHA,SAAA5B,GACA,YAOA,SAAAY,GAAAR,EAAAgC,GAEAA,EAAAA,MACAC,KAAAjC,QAAAA,EACAiC,KAAA1B,GAAAyB,EAAAzB,GAEA0B,KAAAxB,QAAAuB,EAAAvB,QAEAwB,KAAAf,WAAA,WAEAe,KAAAC,WAAA,EACAD,KAAAE,SACAH,EAAAd,WAAAe,KAAAjC,UACAoC,KAAAH,KASA,IAAAI,GAAAJ,KAAAjC,QAAAsC,MAAAD,OACAJ,MAAAM,aAAAF,EACAJ,KAAAO,SAEAP,KAAAQ,mBACAR,KAAAS,WACAT,KAAAU,aAAA,GACAV,KAAAW,YAAA,EACAX,KAAAY,cAAA,EAEAZ,KAAAC,WAAA,EAEAD,KAAAa,UAAA,EACAb,KAAAc,gBAAA,EACAd,KAAAe,gBAEAf,KAAAgB,QAAAhB,KAAAgB,QAAAb,KAAAH,MACAA,KAAAiB,MAAAjB,KAAAiB,MAAAd,KAAAH,MACAA,KAAAkB,MAAAlB,KAAAkB,MAAAf,KAAAH,MA5CA,GAAAmB,GAAA,IACAC,EAAA,OACAC,EAAA,CA6CA9C,GAAA+C,WAEAC,qBAAA,WACA,GAAAC,MACAC,EAAA,GAAAC,SAAA,SAAAC,EAAAC,GACAJ,EAAAG,QAAAA,EACAH,EAAAI,OAAAA,GAOA,OALAH,GAAAT,QAAAhB,KAAAgB,QACAS,EAAAR,MAAAjB,KAAAiB,MACAQ,EAAAP,MAAAlB,KAAAkB,MACAM,EAAAC,QAAAA,EAEAD,GASAK,mBAAA,SAAA9D,EAAA+D,GACA,GAAAC,GAAAC,iBAAAjE,GAAAkE,SAEAlE,GAAAsC,MAAA4B,UADA,SAAAF,EACAD,EAEAC,EAAA,IAAAD,GAUAI,2BAAA,aASAC,SAAA,aAMAnB,QAAA,WAGA,GAAAoB,GAAAC,MAAAf,UAAAgB,MAAAC,KAAAC,UAEA,KAAAJ,EAAA,GACA,KAAA,IAAApE,OAAA,2BAGA,IAAA,gBAAAoE,GAAA,GAEA,KAAA,IAAApE,OAAA,wBAGA,IAAA,gBAAAoE,GAAA,GAAA,CACA,GAAAK,GAAAL,EAAA,GACArC,EAAAqC,EAAA,OAEAM,IACA,KAAA,GAAAC,KAAAF,GACAC,EAAA/D,KAAAgE,EAEA,IAAAC,GAAAF,EAAAG,KAAA,IACA9C,GAAA+C,SAAA/C,EAAA+C,UAAA3B,EACAnB,KAAAQ,gBAAA7B,KAAAoB,EAAA+C,UACA9C,KAAAS,QAAA9B,KAAAoB,EAAA+C,SAEA,IAAAC,GAAA/C,KACAgD,GACAP,WAAAA,EACA1C,QAAAA,EACAkD,MAAA,WACAF,EAAAhF,QAAAsC,MAAAuC,mBAAAA,EACAG,EAAAhF,QAAAsC,MAAA6C,mBAAAnD,EAAA+C,SAAA,KACAC,EAAAhF,QAAAsC,MAAA8C,yBAAApD,EAAAqD,QAAAhC,EAIA2B,EAAAhF,QAAAsF,WACA,KAAA,GAAAV,KAAAF,GACAM,EAAAhF,QAAAsC,MAAAsC,GAAAF,EAAAE,EAGA5C,GAAAkD,OACAlD,EAAAkD,SAKAjD,MAAAO,MAAA5B,KAAAqE,GACAhD,KAAAxB,QAAAwB,KAAA1B,GAEA,IAAAkD,GAAAxB,KAAAuB,sBAEA,OADAvB,MAAAe,aAAApC,KAAA6C,GACAA,EAAAC,UASAR,MAAA,SAAAqC,GACA,KAAAA,EAAA,GAKA,KAAA,IAAAtF,OAAA,2BAJAgC,MAAAO,MAAA5B,SACAqB,KAAAQ,gBAAA7B,KAAA2E,GACAtD,KAAAS,QAAA9B,KAAA2E,GAKAtD,KAAAxB,QAAAwB,KAAA1B,GAEA,IAAAkD,GAAAxB,KAAAuB,sBAEA,OADAvB,MAAAe,aAAApC,KAAA6C,GACAA,EAAAC,SAOAP,MAAA,WAKA,MAJAlB,MAAAC,YACAD,KAAAa,UAAA,GAGAb,MAOAuD,KAAA,WAGA,MAFAvD,MAAAa,UAAA,EAEAb,KAAAe,aAAAf,KAAAU,cAAAe,SAOA+B,MAAA,WAQA,MAPAxD,MAAAjC,QAAAsC,MAAAD,QAAAJ,KAAAM,aACAN,KAAAU,aAAA,GAIAV,KAAAjC,QAAAsF,YACArD,KAAAf,aACAe,MAGAyD,QAAA,aASAC,MAAA,SAAAC,EAAAC,GAKA,GAAAZ,GAAAhD,KAAAO,MAAAP,KAAAU,aAEA,IAAAsC,EAAA,CAIAW,EAAAA,GAAAtC,CAEA,IAGAsB,GAHAF,EAAAO,EAAAP,WACAoB,GAAAb,EAAAjD,QAAA+C,SAAA9C,KAAAW,aAAAgD,EACAG,EAAA9B,iBAAAhC,KAAAjC,QAEA,KAAA4E,IAAAF,GACAzC,KAAAjC,QAAAsC,MAAAsC,GAAAmB,EAAAnB,EAKA3C,MAAAjC,QAAAsF,WAEA,KAAAV,IAAAF,GACAzC,KAAAjC,QAAAsC,MAAAsC,GAAAF,EAAAE,EAOA,IALA3C,KAAAjC,QAAAsC,MAAA6C,mBAAAW,EAAA,KACA7D,KAAAS,QAAAT,KAAAU,cAAAmD,EACA7D,KAAAW,YAAA,EACAX,KAAAY,cAAA,EAEAgD,EAEA,IAAA,GADAG,GAAA,EACAC,EAAAhE,KAAAU,aAAA,EAAAsD,EAAAhE,KAAAO,MAAApB,OAAA6E,IACAD,EAAA/D,KAAAQ,gBAAAwD,GAAAL,EACA3D,KAAAO,MAAAyD,GAAAjE,QAAA+C,SAAAiB,EACA/D,KAAAS,QAAAuD,GAAAD,CAIA,OAAA/D,QAOAiE,KAAA,WAKA,MAJAjE,MAAAC,YACAD,KAAAkE,MAAAlE,KAAAU,cACAV,KAAAmE,SAEAnE,MAGAkE,MAAA,SAAAE,GAEA,IAAApE,KAAAO,MAAA6D,KAAApE,KAAAO,MAAA6D,GAAA3B,WACA,OAAA,CAEA,IAAAA,GAAAzC,KAAAO,MAAA6D,GAAA3B,UAEAzC,MAAAjC,QAAAsC,MAAAuC,mBAAA,MAEA,KAAA,GAAAD,KAAAF,GACAzC,KAAAjC,QAAAsC,MAAAsC,GAAAF,EAAAE,EAOA,OAFA3C,MAAAjC,QAAAsF,aAEA,GAOAgB,OAAA,WACA,GAAArE,KAAAO,MAAApB,OAAA,EACA,MAAAa,KAIA,KADA,GAAAoE,GAAApE,KAAAO,MAAApB,OAAA,GACAa,KAAAkE,MAAAE,IAAAA,EAAA,IACAA,GAAA,CAKA,IAAArD,GAAAf,KAAAe,YASA,OAPAf,MAAAU,aAAAV,KAAAO,MAAApB,OAAA,EACAa,KAAAf,aAEA8B,EAAAzB,QAAA,SAAAmC,GACAA,EAAAE,YAGA3B,MAGAhB,KAAA,SAAAK,GAOA,IALAW,KAAAa,UAAAb,KAAAY,gBACAZ,KAAAW,aAAAtB,EAAAW,KAAAY,eAEAZ,KAAAY,cAAAvB,GAEAW,KAAAC,UAGA,MAFAD,MAAAC,WAAA,MACAD,MAAAmE,OAIA,KAAAnE,KAAAa,WAAAb,KAAAc,eAAA,CAIA,GAAAkC,GACAP,EACAE,CAEA,KAAA3C,KAAAa,UAAAb,KAAAc,eAcA,GAAAd,KAAAa,WAAAb,KAAAc,gBAgBA,GAAAd,KAAAW,YAAAX,KAAAS,QAAAT,KAAAU,cAAA,CACAsC,EAAAhD,KAAAO,MAAAP,KAAAU,cACAsC,EAAAjD,SAAA,kBAAAiD,GAAAjD,QAAAuE,UACAtB,EAAAjD,QAAAuE,UAEA,IAAA9C,GAAAxB,KAAAe,aAAAf,KAAAU,aACAc,GAAAG,UACA3B,KAAAmE,aAvBA,CACAnE,KAAAc,gBAAA,EACAkC,EAAAhD,KAAAO,MAAAP,KAAAU,cACA+B,EAAAO,EAAAP,UAEA,KAAAE,IAAAF,GACAzC,KAAAjC,QAAAsC,MAAAsC,GAAAF,EAAAE,OApBA,CAEA3C,KAAAc,gBAAA,CACA,IAAAgD,GAAA9B,iBAAAhC,KAAAjC,QACAiF,GAAAhD,KAAAO,MAAAP,KAAAU,cACA+B,EAAAO,EAAAP,UAEA,KAAAE,IAAAF,GACAzC,KAAAjC,QAAAsC,MAAAsC,GAAAmB,EAAAnB,MAiCAwB,MAAA,WAGA,GAFAnE,KAAAU,cAAA,EAEAV,KAAAO,MAAAP,KAAAU,cAAA,CAEA,GAAAsC,GAAAhD,KAAAO,MAAAP,KAAAU,aACAsC,GAAAjD,SAAA,kBAAAiD,GAAAjD,QAAAwE,QACAvB,EAAAjD,QAAAwE,SAGAvB,EAAAC,OAAA,kBAAAD,GAAAC,OACAD,EAAAC,YAIApE,SAAAC,IAAAkB,KAAA1B,GAAA,OACA0B,KAAAU,cAAA,EACAV,KAAAf,YAGAe,MAAAW,YAAA,EACAX,KAAAY,cAAA,GAOAV,OAAA,WACA,IAAA,GAAA8D,GAAA,EAAAA,EAAAhE,KAAAO,MAAApB,OAAA6E,IACAhE,KAAAO,MAAAyD,GAAAjE,UACAC,KAAAO,MAAAyD,GAAAjE,QAAA+C,SAAA9C,KAAAQ,gBAAAwD,IAEAhE,KAAAS,QAAAuD,GAAAhE,KAAAQ,gBAAAwD,IAIAQ,OAAA,WACAxE,KAAAU,aAAA,GACAV,KAAAO,MAAApB,OAAA,EACAa,KAAAQ,gBAAArB,OAAA,EACAa,KAAAS,QAAAtB,OAAA,EACAa,KAAAW,YAAA,EACAX,KAAAY,cAAA,EACAZ,KAAAC,WAAA,EACAD,KAAAa,UAAA,EACAb,KAAAc,gBAAA,EACAd,KAAAe,kBAIApD,EAAAY,WAAAA,GAEAgB","file":"goku.min.js","sourcesContent":["/* global Transition */\n(function (exports) {\n  'use strict';\n\n  var requestId;\n  // Transition elements\n  var elements = {};\n  // Elements that are running animations\n  var animatingElements = [];\n\n  var gokuIndex = 0;\n\n  var requestAnimationFrame = window.requestAnimationFrame ||\n                              window.webkitRequestAnimationFrame ||\n                              window.mozRequestAnimationFrame ||\n                              function fakeAnimationFrame(callback) {\n                                return window.setTimeout(callback, 1000 / 60);\n                              };\n\n  var cancelAnimationFrame = window.cancelAnimationFrame ||\n                             window.webkitCancelAnimationFrame ||\n                             window.mozCancelAnimationFrame ||\n                             function fakeAnimationFrame(id) {\n                               window.clearTimeout(id);\n                             };\n\n  function isObjectEmpty(obj) {\n    if (!obj) {\n      return true;\n    }\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function newId () {\n    return 'goku-' + gokuIndex++;\n  }\n\n  function goku (element) {\n    if (!element) {\n      throw new Error('Goku: no argument');\n    }\n\n    if (typeof element === 'string') {\n      element = document.querySelector(element);\n    }\n\n    if (!element) {\n      throw new Error('Goku: no element found');\n    }\n\n    if (elements[element.dataset.gokuId]) {\n      return elements[element.dataset.gokuId];\n    }\n\n    // Use MutationObserver to release the obj when done\n    // https://developer.mozilla.org/en/docs/Web/API/MutationObserver\n    // https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\n    // http://jsbin.com/yeferi/1/edit?html,js,console,output\n\n    var id = newId();\n\n    element.dataset.gokuId = id;\n\n    elements[id] = new Transition(element, {\n      id: id,\n      onstart: function (id) {\n        if (animatingElements.indexOf(id) < 0) {\n          animatingElements.push(id);\n        }\n        if (!requestId) {\n          console.log('goku.js: start animation loop');\n          requestId = requestAnimationFrame(step);\n        }\n      },\n      oncomplete: function (element) {\n        var id = element.dataset.gokuId;\n\n        if (animatingElements.indexOf(id) > -1) {\n          animatingElements.splice(animatingElements.indexOf(id), 1);\n        }\n        if (animatingElements.length < 1) {\n          console.log('goku.js: complete animation loop');\n          cancelAnimationFrame(requestId);\n          requestId = null;\n        }\n      }\n    });\n\n    return elements[id];\n  }\n\n  /**\n   * The main and only loop for monitoring animated elements.\n   * @param  {[type]} timestamp [description]\n   * @return {[type]}           [description]\n   */\n  function step (timestamp) {\n    requestId = requestAnimationFrame(step);\n\n    animatingElements.forEach(function (id) {\n      if (elements[id].step) {\n        elements[id].step(timestamp);\n      }\n    });\n  }\n\n  exports.goku = goku;\n\n})(window);\n","(function (exports) {\n  'use strict';\n\n  // var TRANSITION_FINISH_THRESHOLD = 0;\n  var DEFAULT_DURATION = 400;\n  var DEFAULT_EASING = 'ease';\n  var DEFAULT_SPEED_RATIO = 4;\n\n  function Transition (element, options) {\n    // Currently only support ES6 Promise, add support for various promise implementations later.\n    options = options || {};\n    this.element = element;\n    this.id = options.id;\n    // The callback to notify the goku instance (animation element manager) that the animations for this element has started.\n    this.onstart = options.onstart;\n    // The callback to notify the goku instance (animation element manager) that the animations for this element has stopped.\n    this.oncomplete = function () {\n      // Need to reset timings first since they might be modified by speed.\n      this.isStarted = false;\n      this._reset();\n      options.oncomplete(this.element);\n    }.bind(this);\n\n    // this.element.style.transitionProperty = 'transform';\n    // log purpose only\n    // this.element.addEventListener('transitionend', function (evt) {\n    //   console.log('transitionend', evt);\n    // });\n\n    // Store the default style before running animations.\n    var cssText = this.element.style.cssText;\n    this.defaultStyle = cssText;\n    this.queue = [];\n    // Store original animation timings, timings can be changed by speed method.\n    this.originalTimings = [];\n    this.timings = [];\n    this.playingIndex = -1;\n    this.elapsedTime = 0;\n    this.lastTimestamp = 0;\n    // Is any animation started running\n    this.isStarted = false;\n    // Is the running animation paused\n    this.isPaused = false;\n    this.isPauseHandled = false;\n    this.promiseQueue = [];\n\n    this.animate = this.animate.bind(this);\n    this.delay = this.delay.bind(this);\n    this.pause = this.pause.bind(this);\n  }\n\n  Transition.prototype = {\n\n    _generatePromiseTask: function () {\n      var promiseTask = {};\n      var promise = new Promise(function (resolve, reject) {\n        promiseTask.resolve = resolve;\n        promiseTask.reject = reject;\n      });\n      promise.animate = this.animate;\n      promise.delay = this.delay;\n      promise.pause = this.pause;\n      promiseTask.promise = promise;\n\n      return promiseTask;\n    },\n\n    /**\n     * Update the transform value of an element by chaining the original and the new transform values.\n     * @param  {[type]} element [description]\n     * @param  {[type]} value   [description]\n     * @return {[type]}         [description]\n     */\n    _generateTransform: function (element, value) {\n      var originalTransform = getComputedStyle(element).transform;\n      if (originalTransform === 'none') {\n        element.style.transform = value;\n      } else {\n        element.style.transform = originalTransform + ' ' + value;\n      }\n    },\n\n    /**\n     * Maybe try this approach later for performance comparisons.\n     * @param  {[type]} element [description]\n     * @param  {[type]} value   [description]\n     * @return {[type]}         [description]\n     */\n    _generateTransformByMatrix: function (/*element, value*/) {\n      // If transform was applied on the element\n        // Get originial transform matrix\n        // Get new transform matrix\n        // Compute the result transform matrix\n      // Else, set the value directly\n\n    },\n\n    addClass: function (/*className*/) {},\n\n    /**\n     * By default the animate calls are queued.\n     * @return {[type]} [description]\n     */\n    animate: function () {\n      // Optimize this later\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n      var args = Array.prototype.slice.call(arguments);\n\n      if (!args[0]) {\n        throw new Error('Goku: missing arguments!');\n      }\n\n      if (typeof args[0] === 'string') {\n        // Run animation by adding CSS class\n        throw new Error('Goku: implement this!');\n      }\n\n      if (typeof args[0] === 'object') {\n        var properties = args[0];\n        var options = args[1] || {};\n\n        var transitionPropertyArray = [];\n        for (var key in properties) {\n          transitionPropertyArray.push(key);\n        }\n        var transitionProperty = transitionPropertyArray.join(' ');\n        options.duration = options.duration || DEFAULT_DURATION;\n        this.originalTimings.push(options.duration);\n        this.timings.push(options.duration);\n\n        var that = this;\n        var task = {\n          properties: properties,\n          options: options,\n          start: function () {\n            that.element.style.transitionProperty = transitionProperty;\n            that.element.style.transitionDuration = options.duration + 'ms';\n            that.element.style.transitionTimingFunction = options.easing || DEFAULT_EASING;\n            // Force a transition.\n            // http://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element\n            /* jshint -W030 */\n            that.element.offsetWidth;\n            for (var key in properties) {\n              that.element.style[key] = properties[key];\n            }\n\n            if (options.start) {\n              options.start();\n            }\n          }\n        };\n\n        this.queue.push(task);\n        this.onstart(this.id);\n\n        var promiseTask = this._generatePromiseTask();\n        this.promiseQueue.push(promiseTask);\n        return promiseTask.promise;\n      }\n    },\n\n    /**\n     * Delay the next animation for the specified time in miliseconds.\n     * @param  {[type]} time [description]\n     * @return {[type]}      [description]\n     */\n    delay: function (time) {\n      if (time > 0) {\n        this.queue.push({});\n        this.originalTimings.push(time);\n        this.timings.push(time);\n      } else {\n        throw new Error('Goku: missing arguments!');\n      }\n\n      this.onstart(this.id);\n\n      var promiseTask = this._generatePromiseTask();\n      this.promiseQueue.push(promiseTask);\n      return promiseTask.promise;\n    },\n\n    /**\n     * Pause the current animation.\n     * @return {[type]} [description]\n     */\n    pause: function () {\n      if (this.isStarted) {\n        this.isPaused = true;\n      }\n\n      return this;\n    },\n\n    /**\n     * Resume a pausing animation.\n     * @return {[type]} [description]\n     */\n    play: function () {\n      this.isPaused = false;\n\n      return this.promiseQueue[this.playingIndex].promise;\n    },\n\n    /**\n     * Reset the element to the initial state before applying animations.\n     * @return {[type]} [description]\n     */\n    reset: function () {\n      this.element.style.cssText = this.defaultStyle;\n      this.playingIndex = -1;\n      // Force a reflow and repaint.\n      // http://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element\n      /* jshint -W030 */\n      this.element.offsetWidth;\n      this.oncomplete();\n      return this;\n    },\n\n    reverse: function () {\n    },\n\n    /**\n     * Change animation speed. Setting the 2nd parameter to true to change the speed of all queued animations.\n     * @param  {[type]} ratio     [description]\n     * @param  {[type]} jumpToEnd [description]\n     * @return {[type]}           [description]\n     */\n    speed: function (ratio, jumpToEnd) {\n      // Changing only the transition-duration once the transition has started\n      // will not actually shorten or extend the transition duration.\n      // Need to pause the transition first and then start a new transition\n      // with the new duration.\n      var task = this.queue[this.playingIndex];\n\n      if (!task) {\n        return;\n      }\n\n      ratio = ratio || DEFAULT_SPEED_RATIO;\n\n      var properties = task.properties;\n      var remainingTime = (task.options.duration - this.elapsedTime) / ratio;\n      var styles = getComputedStyle(this.element);\n      var key;\n      for (key in properties) {\n        this.element.style[key] = styles[key];\n      }\n      // Force a reflow and repaint.\n      // http://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element\n      /* jshint -W030 */\n      this.element.offsetWidth;\n\n      for (key in properties) {\n        this.element.style[key] = properties[key];\n      }\n      this.element.style.transitionDuration = remainingTime + 'ms';\n      this.timings[this.playingIndex] = remainingTime;\n      this.elapsedTime = 0;\n      this.lastTimestamp = 0;\n\n      if (jumpToEnd) {\n        var newTiming = 0;\n        for (var i = this.playingIndex + 1; i < this.queue.length; i++) {\n          newTiming = this.originalTimings[i] / ratio;\n          this.queue[i].options.duration = newTiming;\n          this.timings[i] = newTiming;\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Stop the current animation.\n     * @return {[type]} [description]\n     */\n    stop: function () {\n      if (this.isStarted) {\n        this._goto(this.playingIndex);\n        this._next();\n      }\n      return this;\n    },\n\n    _goto: function (index) {\n      // Get the last animation task and its properties in the queue\n      if (!this.queue[index] || !this.queue[index].properties) {\n        return false;\n      }\n      var properties = this.queue[index].properties;\n      // Remove transition-properties style\n      this.element.style.transitionProperty = 'none';\n      // Apply the final style properties onto the element\n      for (var key in properties) {\n        this.element.style[key] = properties[key];\n      }\n      // Force a reflow and repaint.\n      // http://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element\n      /* jshint -W030 */\n      this.element.offsetWidth;\n\n      return true;\n    },\n\n    /**\n     * End the animation immediately.\n     * @return {[type]} [description]\n     */\n    finish: function () {\n      if (this.queue.length < 1) {\n        return this;\n      }\n\n      var index = this.queue.length - 1;\n      while (!this._goto(index) && index > -1) {\n        index -= 1;\n      }\n      // Resolving promises following the logic as follows to prevent error\n      // when animate is called in the then() callback.\n      // Save promiseQueue reference to be resolved below.\n      var promiseQueue = this.promiseQueue;\n      // Clean up transition tasks including the promiseQueue.\n      this.playingIndex = this.queue.length - 1;\n      this.oncomplete();\n      // Resolve promises\n      promiseQueue.forEach(function (promise) {\n        promise.resolve();\n      });\n\n      return this;\n    },\n\n    step: function (timestamp) {\n      // timestamp is started when page loaded, reset the elapsed time first\n      if (!this.isPaused && this.lastTimestamp) {\n        this.elapsedTime += timestamp - this.lastTimestamp;\n      }\n      this.lastTimestamp = timestamp;\n\n      if (!this.isStarted) {\n        this.isStarted = true;\n        this._next();\n        return;\n      }\n\n      if (this.isPaused && this.isPauseHandled) {\n        return;\n      }\n\n      var task;\n      var properties;\n      var key;\n\n      if (this.isPaused && !this.isPauseHandled) {\n        // Set the current style to element.style\n        this.isPauseHandled = true;\n        var styles = getComputedStyle(this.element);\n        task = this.queue[this.playingIndex];\n        properties = task.properties;\n\n        for (key in properties) {\n          this.element.style[key] = styles[key];\n        }\n\n        return;\n      }\n\n      if (!this.isPaused && this.isPauseHandled) {\n        this.isPauseHandled = false;\n        task = this.queue[this.playingIndex];\n        properties = task.properties;\n\n        for (key in properties) {\n          this.element.style[key] = properties[key];\n        }\n\n        return;\n      }\n\n      // if (!this.isPaused) {\n      //   console.log('step', this.id, this.elapsedTime);\n      // }\n\n      if (this.elapsedTime > this.timings[this.playingIndex]) {\n        task = this.queue[this.playingIndex];\n        if (task.options && typeof task.options.complete === 'function') {\n          task.options.complete();\n        }\n        var promiseTask = this.promiseQueue[this.playingIndex];\n        promiseTask.resolve();\n        this._next();\n      }\n    },\n\n    _next: function () {\n      this.playingIndex += 1;\n\n      if (this.queue[this.playingIndex]) {\n\n        var task = this.queue[this.playingIndex];\n        if (task.options && typeof task.options.before === 'function') {\n          task.options.before();\n        }\n\n        if (task.start && typeof task.start === 'function') {\n          task.start();\n        }\n\n      } else {\n        console.log(this.id, 'end');\n        this.playingIndex -= 1;\n        this.oncomplete();\n      }\n\n      this.elapsedTime = 0;\n      this.lastTimestamp = 0;\n    },\n\n    /**\n     * Reset animations to it's original settings without changing its state.\n     * @return {[type]} [description]\n     */\n    _reset: function () {\n      for (var i = 0; i < this.queue.length; i++) {\n        if (this.queue[i].options) {\n          this.queue[i].options.duration = this.originalTimings[i];\n        }\n        this.timings[i] = this.originalTimings[i];\n      }\n    },\n\n    _clear: function () {\n      this.playingIndex = -1;\n      this.queue.length = 0;\n      this.originalTimings.length = 0;\n      this.timings.length = 0;\n      this.elapsedTime = 0;\n      this.lastTimestamp = 0;\n      this.isStarted = false;\n      this.isPaused = false;\n      this.isPauseHandled = false;\n      this.promiseQueue = [];\n    }\n  };\n\n  exports.Transition = Transition;\n\n})(window);\n"],"sourceRoot":"/source/"}